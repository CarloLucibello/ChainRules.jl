<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Math · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="ChainRules logo"/></a><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li><a class="toctext" href="api.html">API</a></li><li class="current"><a class="toctext" href="math.html">Math</a><ul class="internal"><li><a class="toctext" href="#Part-1:-What-is-a-Differential-?-1">Part 1: What is a Differential ?</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="math.html">Math</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRules.jl/blob/master/docs/src/math.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Math</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="On-the-Math-of-ChainRules.jl-1" href="#On-the-Math-of-ChainRules.jl-1">On the Math of ChainRules.jl</a></h1><p>This page explain the mathematical underpinnings of ChainRulesCore.jl. Primarily in the abstract. It should not be read as documentation on how things work, but rather on why things work the way they do.</p><p>It is written around the Julia idea of types. Which do not nessicarily correspond too closely with the idea of Programming Language Theory (static) types, nor with type-theory types. The key feature of the the Julia type system is that it enables multiple dispatch.</p><p>As Julia is a dynamic programming language functions can return different types of values depending on the values of their inputs (i.e. not be type stable).</p><p>Because of multiple dispatch, all functions are able to be define different <em>methods</em> depending on the types of the inputs. We thus can have defined different <span>$+$</span> for different input types, and so will not distinguish between them. The functions thus stand alone from the types, except that a set of input types may special case them. Where as most similar definitions might decribe a object as a type and some operations on the type, we can consider them seperately.</p><div class="admonition terminology"><div class="admonition-title">Notation</div><div class="admonition-text"><p>We use some notation here based closely off of how JuliaLang indicates type relationships. &lt;/br&gt;</p><ul><li><span>$d::\mathcal D$</span>: a value <span>$d$</span> of type <span>$\mathcal D$</span>, or the assertion that the value <span>$d$</span> has type <span>$\mathcal D$</span> &lt;/br&gt;</li><li><span>$\mathcal D &lt;: \mathbb D$</span>: the type <span>$\mathcal D$</span> is a subtype of the type <span>$\mathbb D$</span>. In particular, we are only concerned with the case of <span>$\mathbb D$</span> being a type-union. So in this case it can be seen as also saying that <span>$\mathcal D$</span> is a member of the type-union <span>$\mathbb D$</span>.</li></ul></div></div><h3><a class="nav-anchor" id="On-Computational-Practicalities-and-Errors.-1" href="#On-Computational-Practicalities-and-Errors.-1">On Computational Practicalities and Errors.</a></h3><p>In this writeup we will ignore many of the practicalities of computation. For example we will treat <code>Float64</code> as if they were the real number field. We will also ingore basically all errors (except <code>MethodError</code>s). In particular, we will ignore overflow and underflow, and even <code>ArgumentError</code>s. If you attempt to add a <span>$3 \times 3$</span> matrix to a <span>$4 \times 4$</span> matrix, then indeed that does not work. However, we will not let that prevent that from letting us say that <code>Matrix</code> is a differential for <code>Matrix</code>. Roughly speaking on consider all requirements on functions to he an option to do this or throw an error. E.g. that <code>a + b = c</code>, to be <code>a + b = c</code> or <code>a + b</code> throws an error. </p><h2><a class="nav-anchor" id="Part-1:-What-is-a-Differential-?-1" href="#Part-1:-What-is-a-Differential-?-1">Part 1: What is a Differential ?</a></h2><p>We begin by considering some function we would like to differentiate. For the sake of convention, we will consider all functions as having 1 input and 1 output; but that input and output may be a composite object, such as a struct or tuple. Any valid input or output of a function, or any component there of, has a type. Such a type we will call a <strong>Primal Type</strong>.</p><p>Roughly speaking, the <strong>Differential Type</strong> is a type that represents the difference between two primal type value. For a given Primal type there will often be multiple valid Differential types. For example, for the Primal Type of <code>DateTime</code>, the valid Differential Types include: <code>Millisecond</code>, <code>Second</code>, <code>Hour</code>, <code>Day</code> etc.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>There will always be one (the <strong>Zero</strong>). If there is only that one then one normally says that the type is not differentiable. For example booleans, and integers except when they are being uses as special cases of real numbers; as a computational optimization.</p></div></div><h3><a class="nav-anchor" id="Differential-Type-1" href="#Differential-Type-1">Differential Type</a></h3><p>Consider a Primal Type <span>$\mathcal P$</span>. Consider some type <span>$\mathcal D$</span>.</p><ul><li>If there exists a type-union <span>$\mathbb U$</span>, with <span>$\mathcal D &lt;: \mathbb U$</span>,</li><li>if for all <span>$u :: \mathbb U$</span> and for all <span>$p :: \mathcal P$</span>, there exists a <span>$q :: \mathcal P$</span> such that <code>u + p = p + u = q</code></li><li>and for all <span>$d :: \mathcal U$</span>, and for all <span>$x :: \mathbb U$</span>,  exists <span>$s :: \mathbb U$</span> such that <span>$d + x = x + d = s$</span></li></ul><p>then we say that <span>$\mathcal D$</span> is a (valid) differential type for <span>$\mathcal P$</span>. And we write this as <span>$\mathcal D \triangleleft \mathcal P$</span>.</p><p>Note: in this case it is also true that every other type in the type-union <span>$\mathbb D$</span>, and and indeed <span>$\mathbb D$</span> itself are also valid differential types for <span>$\mathcal P$</span>.</p><p>The short version of this is that a differential type is one that is a member of some type-union that is closed  under addition, and that can be added to the primal type to give an element of the primal type</p><p>The important take away is you can add instances of all valid differential types for <span>$\mathcal P$</span>, and know you will always get an instance of valid differential type back.</p><footer><hr/><a class="previous" href="api.html"><span class="direction">Previous</span><span class="title">API</span></a></footer></article></body></html>
