<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="ChainRules logo"/></a><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRules.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Documentation-1" href="#API-Documentation-1">API Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.NO_FIELDS" href="#ChainRulesCore.NO_FIELDS"><code>ChainRulesCore.NO_FIELDS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NO_FIELDS</code></pre><p>Constant for the reverse-mode derivative with respect to a structure that has no fields. The most notable use for this is for the reverse-mode derivative with respect to the function itself, when that function is not a closure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Composite" href="#ChainRulesCore.Composite"><code>ChainRulesCore.Composite</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Composite{P, T} &lt;: AbstractDifferential</code></pre><p>This type represents the differential for a <code>struct</code>/<code>NamedTuple</code>, or <code>Tuple</code>. <code>P</code> is the the corresponding primal type that this is a differential for.</p><p><code>Composite{P}</code> should have fields (technically properties), that match to a subset of the fields of the primal type; and each should be a differential type matching to the primal type of that field. Fields of the P that are not present in the Composite are treated as <code>Zero</code>.</p><p><code>T</code> is an implementation detail representing the backing data structure. For Tuple it will be a Tuple, and for everything else it will be a <code>NamedTuple</code>. It should not be passed in by user.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.DoesNotExist" href="#ChainRulesCore.DoesNotExist"><code>ChainRulesCore.DoesNotExist</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DoesNotExist()</code></pre><p>This differential indicates that the derivative Does Not Exist (D.N.E). It is the differential for a Primal type that is not differentiable. Such an Integer, or Boolean (when not being used as a represention of a valid that normally would be a floating point.) The only valid way to pertube such a values is to not change it at all. As such, <code>DoesNotExist</code> is functionally identical to <code>Zero()</code>, but provides additional semantic information.</p><p>If you are adding this differential to a primal then something is wrong. A optimization package making use of this might like to check for such a case.</p><p>!!! note:     This does not indicate that the derivative it is not implemented,     but rather that mathematically it is not defined.</p><p>This mostly shows up as the deriviative with respect to dimension, index, or size arguments.</p><pre><code class="language-none">    function rrule(fill, x, len::Int)
        y = fill(x, len)
        fill_pullback(ȳ) = (NO_FIELDS, @thunk(sum(Ȳ)), DoesNotExist())
        return y, fill_pullback
    end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.InplaceableThunk" href="#ChainRulesCore.InplaceableThunk"><code>ChainRulesCore.InplaceableThunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InplaceableThunk(val::Thunk, add!::Function)</code></pre><p>A wrapper for a <code>Thunk</code>, that allows it to define an inplace <code>add!</code> function, which is used internally in <code>accumulate!(Δ, ::InplaceableThunk)</code>.</p><p><code>add!</code> should be defined such that: <code>ithunk.add!(Δ) = Δ .+= ithunk.val</code> but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal <code>Thunk</code>).</p><p>Most operations on an <code>InplaceableThunk</code> treat it just like a normal <code>Thunk</code>; and destroy its inplacability.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.One" href="#ChainRulesCore.One"><code>ChainRulesCore.One</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia"> One()</code></pre><p>The Differential which is the multiplicative identity. Basically, this represents <code>1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Thunk(()-&gt;v)</code></pre><p>A thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a differential. <code>@thunk(v)</code> is a macro that expands into <code>Thunk(()-&gt;v)</code>.</p><p>Calling a thunk, calls the wrapped closure. <code>extern</code>ing thunks applies recursively, it also externs the differial that the closure returns. If you do not want that, then simply call the thunk</p><pre><code class="language-none">julia&gt; t = @thunk(@thunk(3))
Thunk(var&quot;##7#9&quot;())

julia&gt; extern(t)
3

julia&gt; t()
Thunk(var&quot;##8#10&quot;())

julia&gt; t()()
3</code></pre><p><strong>When to <code>@thunk</code>?</strong></p><p>When writing <code>rrule</code>s (and to a lesser exent <code>frule</code>s), it is important to <code>@thunk</code> appropriately. Propagation rules that return multiple derivatives may not have all deriviatives used.  By <code>@thunk</code>ing the work required for each derivative, they then compute only what is needed.</p><p><strong>How do thunks prevent work?</strong></p><p>If we have <code>res = pullback(...) = @thunk(f(x)), @thunk(g(x))</code> then if we did <code>dx + res[1]</code> then only <code>f(x)</code> would be evaluated, not <code>g(x)</code>. Also if we did <code>Zero() * res[1]</code> then the result would be <code>Zero()</code> and <code>f(x)</code> would not be evaluated.</p><p><strong>So why not thunk everything?</strong></p><p><code>@thunk</code> creates a closure over the expression, which (effectively) creates a <code>struct</code> with a field for each variable used in the expression, and call overloaded.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. Examples being:</p><ul><li>The expression being a constant</li><li>The expression is merely wrapping something in a <code>struct</code>, such as <code>Adjoint(x)</code> or <code>Diagonal(x)</code></li><li>The expression being itself a <code>thunk</code></li><li>The expression being from another <code>rrule</code> or <code>frule</code> (it would be <code>@thunk</code>ed if required by the defining rule already)</li><li>There is only one derivative being returned, so from the fact that the user called <code>frule</code>/<code>rrule</code> </li></ul><p>they clearly will want to use that one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Zero" href="#ChainRulesCore.Zero"><code>ChainRulesCore.Zero</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Zero()</code></pre><p>The additive identity for differentials. This is basically the same as <code>0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.extern-Tuple{Any}" href="#ChainRulesCore.extern-Tuple{Any}"><code>ChainRulesCore.extern</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extern(x)</code></pre><p>Return <code>x</code> converted to an appropriate non-<code>AbstractDifferential</code> type, for use with external packages that might not handle <code>AbstractDifferential</code> types.</p><p>Note that this function may return an alias (not necessarily a copy) to data wrapped by <code>x</code>, such that mutating <code>extern(x)</code> might mutate <code>x</code> itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">frule(f, x..., ṡelf, Δx...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code>, <code>Δx</code> as the tuple <code>(Δx₁, Δx₂, ...)</code>, and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̇₁, Ω̇₂, ...))</code></pre><p>The second return value is the propagation rule, or the pushforward. It takes in differentials corresponding to the inputs (<code>ẋ₁, ẋ₂, ...</code>) and <code>ṡelf</code> the internal values of the function (for closures).</p><p>If no method matching <code>frule(f, x..., ṡelf, Δx...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; dself = Zero()
Zero()

julia&gt; x = rand();

julia&gt; sinx, sin_pushforward = frule(sin, x, dself, 1)
(0.35696518021277485, 0.9341176907197836)

julia&gt; sinx == sin(x)
true

julia&gt; sin_pushforward == cos(x)
true</code></pre><p>unary input, binary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sincosx, sincos_pushforward = frule(sincos, x, dself, 1);

julia&gt; sincosx == sincos(x)
true

julia&gt; sincos_pushforward == (cos(x), -sin(x))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rrule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̄₁, Ω̄₂, ...) -&gt; (s̄elf, x̄₁, x̄₂, ...))</code></pre><p>Where the second return value is the the propagation rule or pullback. It takes in differentials corresponding to the outputs (<code>x̄₁, x̄₂, ...</code>), and <code>s̄elf</code>, the internal values of the function itself (for closures)</p><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sinx, sin_pullback = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pullback(1) == (NO_FIELDS, cos(x))
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x, y = rand(2);

julia&gt; hypotxy, hypot_pullback = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; hypot_pullback(1) == (NO_FIELDS, (x / hypot(x, y)), (y / hypot(x, y)))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.store!-Tuple{Any,Any}" href="#ChainRulesCore.store!-Tuple{Any,Any}"><code>ChainRulesCore.store!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">store!(Δ, ∂)</code></pre><p>Stores <code>∂</code>, in <code>Δ</code>, overwriting what ever was in <code>Δ</code> before. potentially avoiding intermediate temporary allocations that might be necessary for alternative approaches  (e.g. <code>copyto!(Δ, extern(∂))</code>)</p><p>Like <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a> and <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>accumulate!</code></a>, this function is intended to be customizable for specific rules/input types.</p><p>See also: <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>accumulate!</code></a>, <a href="@ref"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.unthunk-Tuple{Any}" href="#ChainRulesCore.unthunk-Tuple{Any}"><code>ChainRulesCore.unthunk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unthunk(x)</code></pre><p>On <code>AbstractThunk</code>s this removes 1 layer of thunking. On any other type, it is the identity operation.</p><p>In contrast to <code>extern</code> this is nonrecursive.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-none">function ChainRulesCore.frule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (_, Δx₁, Δx₂, ...) -&gt; (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (ΔΩ₁, ΔΩ₂, ...) -&gt; (
            NO_FIELDS,
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>At present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always <code>NO_FIELDS</code>. And in forward-mode, the first input to the returned propagator is always ignored.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRulesCore&#39; <code>rules</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="@ref"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.@thunk-Tuple{Any}" href="#ChainRulesCore.@thunk-Tuple{Any}"><code>ChainRulesCore.@thunk</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@thunk expr</code></pre><p>Define a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> wrapping the <code>expr</code>, to lazily defer its evaluation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.AbstractDifferential" href="#ChainRulesCore.AbstractDifferential"><code>ChainRulesCore.AbstractDifferential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The subtypes of <code>AbstractDifferential</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>All subtypes of <code>AbstractDifferential</code> implement the following operations:</p><p><code>+(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></p><p><code>*(a, b)</code>: multiply the differential <code>a</code> by the differential <code>b</code></p><p><code>Base.conj(x)</code>: complex conjugate of the differential <code>x</code></p><p><code>extern(x)</code>: convert <code>x</code> into an appropriate non-<code>AbstractDifferential</code> type for use outside of <code>ChainContext</code>.</p><p>Valid arguments to these operations are <code>T</code> where <code>T&lt;:AbstractDifferential</code>, or where <code>T</code> has proper <code>+</code> and <code>*</code> implementations.</p><p>Additionally, all subtypes of <code>AbstractDifferential</code> support <code>Base.iterate</code> and <code>Base.Broadcast.broadcastable(x)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}" href="#ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}"><code>ChainRulesCore._normalize_scalarrules_macro_input</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_normalize_scalarrules_macro_input(call, maybe_setup, partials)</code></pre><p>returns (in order) the correctly escaped:     - <code>call</code> with out any type constraints     - <code>setup_stmts</code>: the content of <code>@setup</code> or <code>nothing</code> if that is not provided,     -  <code>inputs</code>: with all args having the constraints removed from call, or         defaulting to <code>Number</code>     - <code>partials</code>: which are all <code>Expr{:tuple,...}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.accumulate!-Tuple{Any,Any}" href="#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>ChainRulesCore.accumulate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accumulate!(Δ, ∂)</code></pre><p>Similar to <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a>, but attempts to compute <code>Δ + rule(args...)</code> in-place, storing the result in <code>Δ</code>.</p><p>Note: this function may not actually store the result in <code>Δ</code> if <code>Δ</code> is immutable, so it is best to always call this as <code>Δ = accumulate!(Δ, ∂)</code> just in-case.</p><p>This function is overloadable by using a <a href="@ref"><code>InplaceThunk</code></a>. See also: <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,Any}"><code>store!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.accumulate-Tuple{Any,Any}" href="#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>ChainRulesCore.accumulate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accumulate(Δ, ∂)</code></pre><p>Return <code>Δ + ∂</code> evaluated in a manner that supports ChainRulesCore&#39;s various <code>AbstractDifferential</code> types.</p><p>See also: <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>accumulate!</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,Any}"><code>store!</code></a>, <a href="@ref"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.backing-Tuple{Tuple}" href="#ChainRulesCore.backing-Tuple{Tuple}"><code>ChainRulesCore.backing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">backing(x)</code></pre><p>Accesses the backing field of a <code>Composite</code>, or destructures any other composite type into a <code>NamedTuple</code>. Identity function on <code>Tuple</code>. and <code>NamedTuple</code>s.</p><p>This is an internal function used to simplify operations between <code>Composite</code>s and the primal types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.construct-Union{Tuple{L}, Tuple{T}, Tuple{Type{T},NamedTuple{L,T} where T&lt;:Tuple}} where L where T" href="#ChainRulesCore.construct-Union{Tuple{L}, Tuple{T}, Tuple{Type{T},NamedTuple{L,T} where T&lt;:Tuple}} where L where T"><code>ChainRulesCore.construct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">construct(::Type{T}, fields::[NamedTuple|Tuple])</code></pre><p>Constructs an object of type <code>T</code>, with the given fields. Fields must be correct in name and type, and <code>T</code> must have a default constructor.</p><p>This internally is called to construct structs of the primal type <code>T</code>, after an operation such as the addition of a primal to a composite.</p><p>It should be overloaded, if <code>T</code> does not have a default constructor, or if <code>T</code> needs to maintain some invarients between its fields.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.propagation_expr-Tuple{Any,Any}" href="#ChainRulesCore.propagation_expr-Tuple{Any,Any}"><code>ChainRulesCore.propagation_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propagation_expr(Δs, ∂s)

Returns the expression for the propagation of
the input gradient `Δs` though the partials `∂s`.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.propagator_name-Tuple{Expr,Symbol}" href="#ChainRulesCore.propagator_name-Tuple{Expr,Symbol}"><code>ChainRulesCore.propagator_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propagator_name(f, propname)</code></pre><p>Determines a reasonable name for the propagator function. The name doesn&#39;t really matter too much as it is a local function to be returned by <code>frule</code> or <code>rrule</code>, but a good name make debugging easier. <code>f</code> should be some form of AST representation of the actual function, <code>propname</code> should be either <code>:pullback</code> or <code>:pushforward</code></p><p>This is able to deal with fairly complex expressions for <code>f</code>:</p><pre><code class="language-none">julia&gt; propagator_name(:bar, :pushforward)
:bar_pushforward

julia&gt; propagator_name(esc(:(Base.Random.foo)), :pullback)
:foo_pullback</code></pre></div></div></section><footer><hr/><a class="previous" href="getting_started.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a></footer></article></body></html>
