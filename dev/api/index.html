<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ChainRules API Documentation · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li class="current"><a class="toctext" href>ChainRules API Documentation</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>ChainRules API Documentation</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRules.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ChainRules API Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ChainRules-API-Documentation-1" href="#ChainRules-API-Documentation-1">ChainRules API Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.frule" href="#ChainRules.frule"><code>ChainRules.frule</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">frule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (rule_for_ΔΩ₁::AbstractRule, rule_for_ΔΩ₂::AbstractRule, ...))</code></pre><p>where each returned propagation rule <code>rule_for_ΔΩᵢ</code> can be invoked as</p><pre><code class="language-none">rule_for_ΔΩᵢ(Δx₁, Δx₂, ...)</code></pre><p>to yield <code>Ωᵢ</code>&#39;s corresponding differential <code>ΔΩᵢ</code>. To illustrate, if all involved values are real-valued scalars, this differential can be written as:</p><pre><code class="language-none">ΔΩᵢ = ∂Ωᵢ_∂x₁ * Δx₁ + ∂Ωᵢ_∂x₂ * Δx₂ + ...</code></pre><p>If no method matching <code>frule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sinx, dsin = frule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; dsin(1) == cos(x)
true</code></pre><p>unary input, binary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sincosx, (dsin, dcos) = frule(sincos, x);

julia&gt; sincosx == sincos(x)
true

julia&gt; dsin(1) == cos(x)
true

julia&gt; dcos(1) == -sin(x)
true</code></pre><p>See also: <a href="#ChainRules.rrule"><code>rrule</code></a>, <a href="#ChainRules.AbstractRule"><code>AbstractRule</code></a>, <a href="@ref"><code>@scalar_rule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L268-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.rrule" href="#ChainRules.rrule"><code>ChainRules.rrule</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rrule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (rule_for_Δx₁::AbstractRule, rule_for_Δx₂::AbstractRule, ...))</code></pre><p>where each returned propagation rule <code>rule_for_Δxᵢ</code> can be invoked as</p><pre><code class="language-none">rule_for_Δxᵢ(ΔΩ₁, ΔΩ₂, ...)</code></pre><p>to yield <code>xᵢ</code>&#39;s corresponding differential <code>Δxᵢ</code>. To illustrate, if all involved values are real-valued scalars, this differential can be written as:</p><pre><code class="language-none">Δxᵢ = ∂Ω₁_∂xᵢ * ΔΩ₁ + ∂Ω₂_∂xᵢ * ΔΩ₂ + ...</code></pre><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sinx, dx = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; dx(1) == cos(x)
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x, y = rand(2);

julia&gt; hypotxy, (dx, dy) = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; dx(1) == (y / hypot(x, y))
true

julia&gt; dy(1) == (x / hypot(x, y))
true</code></pre><p>See also: <a href="#ChainRules.frule"><code>frule</code></a>, <a href="#ChainRules.AbstractRule"><code>AbstractRule</code></a>, <a href="@ref"><code>@scalar_rule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L324-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.AbstractRule" href="#ChainRules.AbstractRule"><code>ChainRules.AbstractRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Subtypes of <code>AbstractRule</code> are types which represent the primitive derivative propagation &quot;rules&quot; that can be composed to implement forward- and reverse-mode automatic differentiation.</p><p>More specifically, a <code>rule::AbstractRule</code> is a callable Julia object generally obtained via calling <a href="#ChainRules.frule"><code>frule</code></a> or <a href="#ChainRules.rrule"><code>rrule</code></a>. Such rules accept differential values as input, evaluate the chain rule using internally stored/ computed partial derivatives to produce a single differential value, then return that calculated differential value.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; using ChainRules: frule, rrule, AbstractRule

julia&gt; x, y = rand(2);

julia&gt; h, dh = frule(hypot, x, y);

julia&gt; h == hypot(x, y)
true

julia&gt; isa(dh, AbstractRule)
true

julia&gt; Δx, Δy = rand(2);

julia&gt; dh(Δx, Δy) == ((y / h) * Δx + (x / h) * Δy)
true

julia&gt; h, (dx, dy) = rrule(hypot, x, y);

julia&gt; h == hypot(x, y)
true

julia&gt; isa(dx, AbstractRule) &amp;&amp; isa(dy, AbstractRule)
true

julia&gt; Δh = rand();

julia&gt; dx(Δh) == (y / h) * Δh
true

julia&gt; dy(Δh) == (x / h) * Δh
true</code></pre><p>See also: <a href="#ChainRules.frule"><code>frule</code></a>, <a href="#ChainRules.rrule"><code>rrule</code></a>, <a href="#ChainRules.Rule"><code>Rule</code></a>, <a href="#ChainRules.DNERule"><code>DNERule</code></a>, <a href="#ChainRules.WirtingerRule"><code>WirtingerRule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L1-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.Rule" href="#ChainRules.Rule"><code>ChainRules.Rule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Rule(propation_function[, updating_function])</code></pre><p>Return a <code>Rule</code> that wraps the given <code>propation_function</code>. It is assumed that <code>propation_function</code> is a callable object whose arguments are differential values, and whose output is a single differential value calculated by applying internally stored/computed partial derivatives to the input differential values.</p><p>If an updating function is provided, it is assumed to have the signature <code>u(Δ, xs...)</code> and to store the result of the propagation function applied to the arguments <code>xs</code> into <code>Δ</code> in-place, returning <code>Δ</code>.</p><p>For example:</p><pre><code class="language-none">frule(::typeof(*), x, y) = x * y, Rule((Δx, Δy) -&gt; Δx * y + x * Δy)

rrule(::typeof(*), x, y) = x * y, (Rule(ΔΩ -&gt; ΔΩ * y&#39;), Rule(ΔΩ -&gt; x&#39; * ΔΩ))</code></pre><p>See also: <a href="#ChainRules.frule"><code>frule</code></a>, <a href="#ChainRules.rrule"><code>rrule</code></a>, <a href="#ChainRules.accumulate"><code>accumulate</code></a>, <a href="#ChainRules.accumulate!"><code>accumulate!</code></a>, <a href="#ChainRules.store!"><code>store!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L155-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.DNERule" href="#ChainRules.DNERule"><code>ChainRules.DNERule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DNERule(args...)</code></pre><p>Construct a <code>DNERule</code> object, which is an <code>AbstractRule</code> that signifies that the current function is not differentiable with respect to a particular parameter. <strong>DNE</strong> is an abbreviation for Does Not Exist.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L197-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.WirtingerRule" href="#ChainRules.WirtingerRule"><code>ChainRules.WirtingerRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L212-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.accumulate" href="#ChainRules.accumulate"><code>ChainRules.accumulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">accumulate(Δ, rule::AbstractRule, args...)</code></pre><p>Return <code>Δ + rule(args...)</code> evaluated in a manner that supports ChainRules&#39; various <code>AbstractDifferential</code> types.</p><p>This method intended to be customizable for specific rules/input types. For example, here is pseudocode to overload <code>accumulate</code> w.r.t. a specific forward differentiation rule for a given function <code>f</code>:</p><pre><code class="language-none">df(x) = # forward differentiation primitive implementation

frule(::typeof(f), x) = (f(x), Rule(df))

accumulate(Δ, rule::Rule{typeof(df)}, x) = # customized `accumulate` implementation</code></pre><p>See also: <a href="#ChainRules.accumulate!"><code>accumulate!</code></a>, <a href="#ChainRules.store!"><code>store!</code></a>, <a href="#ChainRules.AbstractRule"><code>AbstractRule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L61-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.accumulate!" href="#ChainRules.accumulate!"><code>ChainRules.accumulate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">accumulate!(Δ, rule::AbstractRule, args...)</code></pre><p>Similar to <a href="#ChainRules.accumulate"><code>accumulate</code></a>, but compute <code>Δ + rule(args...)</code> in-place, storing the result in <code>Δ</code>.</p><p>Note that this function internally calls <code>Base.Broadcast.materialize!(Δ, ...)</code>.</p><p>See also: <a href="#ChainRules.accumulate"><code>accumulate</code></a>, <a href="#ChainRules.store!"><code>store!</code></a>, <a href="#ChainRules.AbstractRule"><code>AbstractRule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L83-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.store!" href="#ChainRules.store!"><code>ChainRules.store!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">store!(Δ, rule::AbstractRule, args...)</code></pre><p>Compute <code>rule(args...)</code> and store the result in <code>Δ</code>, potentially avoiding intermediate temporary allocations that might be necessary for alternative approaches (e.g. <code>copyto!(Δ, extern(rule(args...)))</code>)</p><p>Note that this function internally calls <code>Base.Broadcast.materialize!(Δ, ...)</code>.</p><p>Like <a href="#ChainRules.accumulate"><code>accumulate</code></a> and <a href="#ChainRules.accumulate!"><code>accumulate!</code></a>, this function is intended to be customizable for specific rules/input types.</p><p>See also: <a href="#ChainRules.accumulate"><code>accumulate</code></a>, <a href="#ChainRules.accumulate!"><code>accumulate!</code></a>, <a href="#ChainRules.AbstractRule"><code>AbstractRule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/rules.jl#L99-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.AbstractDifferential" href="#ChainRules.AbstractDifferential"><code>ChainRules.AbstractDifferential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The subtypes of <code>AbstractDifferential</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>All subtypes of <code>AbstractDifferential</code> implement the following operations:</p><p><code>add(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></p><p><code>mul(a, b)</code>: multiply the differential <code>a</code> by the differential <code>b</code></p><p><code>Base.conj(x)</code>: complex conjugate of the differential <code>x</code></p><p><code>extern(x)</code>: convert <code>x</code> into an appropriate non-<code>AbstractDifferential</code> type for use outside of <code>ChainContext</code>.</p><p>Valid arguments to these operations are <code>T</code> where <code>T&lt;:AbstractDifferential</code>, or where <code>T</code> has proper <code>+</code> and <code>*</code> implementations.</p><p>Additionally, all subtypes of <code>AbstractDifferential</code> support <code>Base.iterate</code> and <code>Base.Broadcast.broadcastable(x)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L5-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.extern" href="#ChainRules.extern"><code>ChainRules.extern</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extern(x)</code></pre><p>Return <code>x</code> converted to an appropriate non-<code>AbstractDifferential</code> type, for use with external packages that might not handle <code>AbstractDifferential</code> types.</p><p>Note that this function may return an alias (not necessarily a copy) to data wrapped by <code>x</code>, such that mutating <code>extern(x)</code> might mutate <code>x</code> itself.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L29-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.Casted" href="#ChainRules.Casted"><code>ChainRules.Casted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L155-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.Wirtinger" href="#ChainRules.Wirtinger"><code>ChainRules.Wirtinger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Wirtinger(primal::Union{Number,AbstractDifferential},
          conjugate::Union{Number,AbstractDifferential})</code></pre><p>Returns a <code>Wirtinger</code> instance representing the complex differential:</p><pre><code class="language-none">df = ∂f/∂z * dz + ∂f/∂z̄ * dz̄</code></pre><p>where <code>primal</code> corresponds to <code>∂f/∂z * dz</code> and <code>conjugate</code> corresponds to <code>∂f/∂z̄ * dz̄</code>.</p><p>The two fields of the returned instance can be accessed generically via the <a href="@ref"><code>wirtinger_primal</code></a> and <a href="@ref"><code>wirtinger_conjugate</code></a> methods.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L80-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.Thunk" href="#ChainRules.Thunk"><code>ChainRules.Thunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L258-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.Zero" href="#ChainRules.Zero"><code>ChainRules.Zero</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L186-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.DNE" href="#ChainRules.DNE"><code>ChainRules.DNE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L210-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRules.One" href="#ChainRules.One"><code>ChainRules.One</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRules.jl/blob/8f754f38bcb5c7d3f307a20e4273a2f31f159565/src/differentials.jl#L234-L236">source</a></section><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting Started</span></a></footer></article></body></html>
