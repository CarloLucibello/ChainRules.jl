var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Documentation-1","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api.html#","page":"API","title":"API","text":"Modules = [ChainRulesCore]","category":"page"},{"location":"api.html#ChainRulesCore.NO_FIELDS","page":"API","title":"ChainRulesCore.NO_FIELDS","text":"NO_FIELDS\n\nConstant for the reverse-mode derivative with respect to a structure that has no fields. The most notable use for this is for the reverse-mode derivative with respect to the function itself, when that function is not a closure.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#ChainRulesCore.Casted","page":"API","title":"ChainRulesCore.Casted","text":"Casted(v)\n\nThis differential wraps another differential (including a number-like type) to indicate that it should be lazily broadcast.\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.DNE","page":"API","title":"ChainRulesCore.DNE","text":"DNE()\n\nThis differential indicates that the derivative Does Not Exist (D.N.E). This is not the cast that it is not implemented, but rather that it mathematically is not defined.\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.InplaceableThunk","page":"API","title":"ChainRulesCore.InplaceableThunk","text":"InplaceableThunk(val::Thunk, add!::Function)\n\nA wrapper for a Thunk, that allows it to define an inplace add! function, which is used internally in accumulate!(Δ, ::InplaceableThunk).\n\nadd! should be defined such that: ithunk.add!(Δ) = Δ .+= ithunk.val but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal Thunk).\n\nMost operations on an InplaceableThunk treat it just like a normal Thunk; and destroy its inplacability.\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.One","page":"API","title":"ChainRulesCore.One","text":" One()\n\nThe Differential which is the multiplicative identity. Basically, this represents 1.\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.Thunk","page":"API","title":"ChainRulesCore.Thunk","text":"Thunk(()->v)\n\nA thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a differential. @thunk(v) is a macro that expands into Thunk(()->v).\n\nCalling a thunk, calls the wrapped closure. externing thunks applies recursively, it also externs the differial that the closure returns. If you do not want that, then simply call the thunk\n\njulia> t = @thunk(@thunk(3))\nThunk(var\"##7#9\"())\n\njulia> extern(t)\n3\n\njulia> t()\nThunk(var\"##8#10\"())\n\njulia> t()()\n3\n\nWhen to @thunk?\n\nWhen writing rrules (and to a lesser exent frules), it is important to @thunk appropriately. Propagation rule's that return multiple derivatives are not able to do all the computing themselves.  By @thunking the work required for each, they then compute only what is needed.\n\nSo why not thunk everything?\n\n@thunk creates a closure over the expression, which (effectively) creates a struct with a field for each variable used in the expression, and call overloaded.\n\nDo not use @thunk if this would be equal or more work than actually evaluating the expression itself. Examples being:\n\nThe expression wrapping something in a struct, such as Adjoint(x) or Diagonal(x)\nThe expression being a constant\nThe expression being itself a thunk\nThe expression being from another rrule or frule (it would be @thunked if required by the defining rule already)\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.Wirtinger","page":"API","title":"ChainRulesCore.Wirtinger","text":"Wirtinger(primal::Union{Number,AbstractDifferential},\n          conjugate::Union{Number,AbstractDifferential})\n\nReturns a Wirtinger instance representing the complex differential:\n\ndf = ∂f/∂z * dz + ∂f/∂z̄ * dz̄\n\nwhere primal corresponds to ∂f/∂z * dz and conjugate corresponds to ∂f/∂z̄ * dz̄.\n\nThe two fields of the returned instance can be accessed generically via the wirtinger_primal and wirtinger_conjugate methods.\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.Zero","page":"API","title":"ChainRulesCore.Zero","text":"Zero()\n\nThe additive identity for differentials. This is basically the same as 0.\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore.extern-Tuple{Any}","page":"API","title":"ChainRulesCore.extern","text":"extern(x)\n\nReturn x converted to an appropriate non-AbstractDifferential type, for use with external packages that might not handle AbstractDifferential types.\n\nNote that this function may return an alias (not necessarily a copy) to data wrapped by x, such that mutating extern(x) might mutate x itself.\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"ChainRulesCore.frule","text":"frule(f, x...)\n\nExpressing x as the tuple (x₁, x₂, ...) and the output tuple of f(x...) as Ω, return the tuple:\n\n(Ω, (ṡelf, ẋ₁, ẋ₂, ...) -> Ω̇₁, Ω̇₂, ...)\n\nThe second return value is the propagation rule, or the pushforward. It takes in differentials corresponding to the inputs (ẋ₁, ẋ₂, ...) and ṡelf the internal values of the function (for closures).\n\nIf no method matching frule(f, xs...) has been defined, then return nothing.\n\nExamples:\n\nunary input, unary output scalar function:\n\njulia> x = rand();\n\njulia> sinx, sin_pushforward = frule(sin, x);\n\njulia> sinx == sin(x)\ntrue\n\njulia> sin_pushforward(NamedTuple(), 1) == cos(x)\ntrue\n\nunary input, binary output scalar function:\n\njulia> x = rand();\n\njulia> sincosx, sincos_pushforward = frule(sincos, x);\n\njulia> sincosx == sincos(x)\ntrue\n\njulia> sincos_pushforward(NamedTuple(), 1) == (cos(x), -sin(x))\ntrue\n\nSee also: rrule, @scalar_rule\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.refine_differential-Tuple{Type{#s15} where #s15<:(Union{AbstractArray{#s17,N} where N where #s17<:Real, #s16} where #s16<:Real),Wirtinger}","page":"API","title":"ChainRulesCore.refine_differential","text":"refine_differential(𝒟::Type, der)\n\nConverts, if required, a differential object der (e.g. a Number, AbstractDifferential, Matrix, etc.), to another  differential that is more suited for the domain given by the type 𝒟. Often this will behave as the identity function on der.\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"ChainRulesCore.rrule","text":"rrule(f, x...)\n\nExpressing x as the tuple (x₁, x₂, ...) and the output tuple of f(x...) as Ω, return the tuple:\n\n(Ω, (Ω̄₁, Ω̄₂, ...) -> (s̄elf, x̄₁, x̄₂, ...))\n\nWhere the second return value is the the propagation rule or pullback. It takes in differentials corresponding to the outputs (x̄₁, x̄₂, ...), and s̄elf, the internal values of the function itself (for closures)\n\nIf no method matching rrule(f, xs...) has been defined, then return nothing.\n\nExamples:\n\nunary input, unary output scalar function:\n\njulia> x = rand();\n\njulia> sinx, sin_pullback = rrule(sin, x);\n\njulia> sinx == sin(x)\ntrue\n\njulia> sin_pullback(1) == (NO_FIELDS, cos(x))\ntrue\n\nbinary input, unary output scalar function:\n\njulia> x, y = rand(2);\n\njulia> hypotxy, hypot_pullback = rrule(hypot, x, y);\n\njulia> hypotxy == hypot(x, y)\ntrue\n\njulia> hypot_pullback(1) == (NO_FIELDS, (x / hypot(x, y)), (y / hypot(x, y)))\ntrue\n\nSee also: frule, @scalar_rule\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.store!-Tuple{Any,Any}","page":"API","title":"ChainRulesCore.store!","text":"store!(Δ, ∂)\n\nStores ∂, in Δ, overwriting what ever was in Δ before. potentially avoiding intermediate temporary allocations that might be necessary for alternative approaches  (e.g. copyto!(Δ, extern(∂)))\n\nLike accumulate and accumulate!, this function is intended to be customizable for specific rules/input types.\n\nSee also: accumulate, accumulate!, AbstractRule\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API","title":"ChainRulesCore.@scalar_rule","text":"@scalar_rule(f(x₁, x₂, ...),\n             @setup(statement₁, statement₂, ...),\n             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),\n             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),\n             ...)\n\nA convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for frule and rrule:\n\nfunction ChainRulesCore.frule(::typeof(f), x₁::Number, x₂::Number, ...)\n    Ω = f(x₁, x₂, ...)\n    $(statement₁, statement₂, ...)\n    return Ω, (_, Δx₁, Δx₂, ...) -> (\n            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),\n            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),\n            ...\n        )\nend\n\nfunction ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)\n    Ω = f(x₁, x₂, ...)\n    $(statement₁, statement₂, ...)\n    return Ω, (ΔΩ₁, ΔΩ₂, ...) -> (\n            NO_FIELDS,\n            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),\n            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),\n            ...\n        )\nend\n\nIf no type constraints in f(x₁, x₂, ...) within the call to @scalar_rule are provided, each parameter in the resulting frule/rrule definition is given a type constraint of Number. Constraints may also be explicitly be provided to override the Number constraint, e.g. f(x₁::Complex, x₂), which will constrain x₁ to Complex and x₂ to Number.\n\nAt present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always NO_FIELDS. And in forward-mode, the first input to the returned propagator is always ignored.\n\nThe result of f(x₁, x₂, ...) is automatically bound to Ω. This allows the primal result to be conveniently referenced (as Ω) within the derivative/setup expressions.\n\nThe @setup argument can be elided if no setup code is need. In other words:\n\n@scalar_rule(f(x₁, x₂, ...),\n             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),\n             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),\n             ...)\n\nis equivalent to:\n\n@scalar_rule(f(x₁, x₂, ...),\n             @setup(nothing),\n             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),\n             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),\n             ...)\n\nFor examples, see ChainRulesCore' rules directory.\n\nSee also: frule, rrule, AbstractRule\n\n\n\n\n\n","category":"macro"},{"location":"api.html#ChainRulesCore.AbstractDifferential","page":"API","title":"ChainRulesCore.AbstractDifferential","text":"The subtypes of AbstractDifferential define a custom \"algebra\" for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.\n\nAll subtypes of AbstractDifferential implement the following operations:\n\n+(a, b): linearly combine differential a and differential b\n\n*(a, b): multiply the differential a by the differential b\n\nBase.conj(x): complex conjugate of the differential x\n\nextern(x): convert x into an appropriate non-AbstractDifferential type for use outside of ChainContext.\n\nValid arguments to these operations are T where T<:AbstractDifferential, or where T has proper + and * implementations.\n\nAdditionally, all subtypes of AbstractDifferential support Base.iterate and Base.Broadcast.broadcastable(x).\n\n\n\n\n\n","category":"type"},{"location":"api.html#ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}","page":"API","title":"ChainRulesCore._normalize_scalarrules_macro_input","text":"_normalize_scalarrules_macro_input(call, maybe_setup, partials)\n\nreturns (in order) the correctly escaped:     - call with out any type constraints     - setup_stmts: the content of @setup or nothing if that is not provided,     -  inputs: with all args having the constraints removed from call, or         defaulting to Number     - partials: which are all Expr{:tuple,...}\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}","page":"API","title":"ChainRulesCore.accumulate!","text":"accumulate!(Δ, ∂)\n\nSimilar to accumulate, but attempts to compute Δ + rule(args...) in-place, storing the result in Δ.\n\nNote: this function may not actually store the result in Δ if Δ is immutable, so it is best to always call this as Δ = accumulate!(Δ, ∂) just in-case.\n\nThis function is overloadable by using a InplaceThunk. See also: accumulate, store!.\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.accumulate-Tuple{Any,Any}","page":"API","title":"ChainRulesCore.accumulate","text":"accumulate(Δ, ∂)\n\nReturn Δ + ∂ evaluated in a manner that supports ChainRulesCore's various AbstractDifferential types.\n\nSee also: accumulate!, store!, AbstractRule\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.propagation_expr-Tuple{Any,Any,Any}","page":"API","title":"ChainRulesCore.propagation_expr","text":"propagation_expr(𝒟, Δs, ∂s)\n\nReturns the expression for the propagation of\nthe input gradient `Δs` though the partials `∂s`.\n\n𝒟 is an expression that when evaluated returns the type-of the input domain.\nFor example if the derivative is being taken at the point `1` it returns `Int`.\nif it is taken at `1+1im` it returns `Complex{Int}`.\nAt present it is ignored for non-Wirtinger derivatives.\n\n\n\n\n\n","category":"method"},{"location":"api.html#ChainRulesCore.propagator_name-Tuple{Expr,Symbol}","page":"API","title":"ChainRulesCore.propagator_name","text":"propagator_name(f, propname)\n\nDetermines a reasonable name for the propagator function. The name doesn't really matter too much as it is a local function to be returned by frule or rrule, but a good name make debugging easier. f should be some form of AST representation of the actual function, propname should be either :pullback or :pushforward\n\nThis is able to deal with fairly complex expressions for f:\n\njulia> propagator_name(:bar, :pushforward)\n:bar_pushforward\n\njulia> propagator_name(esc(:(Base.Random.foo)), :pullback)\n:foo_pullback\n\n\n\n\n\n","category":"method"},{"location":"getting_started.html#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"ChainRulesCore.jl is a light-weight dependency for defining sensitivities for functions in your packages, without you needing to depend on ChainRules itself. It has no dependencies of its own.","category":"page"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"ChainRules.jl provides the full functionality, including sensitivities for Base Julia and standard libraries. Sensitivities for some other packages, currently SpecialFunctions.jl and NaNMath.jl, will also be loaded if those packages are in your environment. In general, we recommend adding custom sensitivities to your own packages with ChainRulesCore, rather than adding them to ChainRules.jl.","category":"page"},{"location":"getting_started.html#Defining-Custom-Sensitivities-1","page":"Getting Started","title":"Defining Custom Sensitivities","text":"","category":"section"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"TODO","category":"page"},{"location":"getting_started.html#Forward-Mode-vs.-Reverse-Mode-Chain-Rule-Evaluation-1","page":"Getting Started","title":"Forward-Mode vs. Reverse-Mode Chain Rule Evaluation","text":"","category":"section"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"TODO","category":"page"},{"location":"getting_started.html#Real-Scalar-Differentiation-Rules-1","page":"Getting Started","title":"Real Scalar Differentiation Rules","text":"","category":"section"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"TODO","category":"page"},{"location":"getting_started.html#Complex-Scalar-Differentiation-Rules-1","page":"Getting Started","title":"Complex Scalar Differentiation Rules","text":"","category":"section"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"TODO","category":"page"},{"location":"getting_started.html#Non-Scalar-Differentiation-Rules-1","page":"Getting Started","title":"Non-Scalar Differentiation Rules","text":"","category":"section"},{"location":"getting_started.html#","page":"Getting Started","title":"Getting Started","text":"TODO","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"DocTestSetup = :(using ChainRulesCore, ChainRules)","category":"page"},{"location":"index.html#ChainRules-1","page":"Introduction","title":"ChainRules","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ChainRules.jl provides a variety of common utilities that can be used by downstream automatic differentiation (AD) tools to define and execute forward-, reverse-, and mixed-mode primitives.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package is a work-in-progress, as is the documentation. Contributions welcome!","category":"page"}]
}
