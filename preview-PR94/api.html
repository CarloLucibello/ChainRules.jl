<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRules.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Documentation-1" href="#API-Documentation-1">API Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.NO_FIELDS" href="#ChainRulesCore.NO_FIELDS"><code>ChainRulesCore.NO_FIELDS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NO_FIELDS</code></pre><p>Constant for the reverse-mode derivative with respect to a structure that has no fields. The most notable use for this is for the reverse-mode derivative with respect to the function itself, when that function is not a closure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Casted" href="#ChainRulesCore.Casted"><code>ChainRulesCore.Casted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Casted(v)</code></pre><p>This differential wraps another differential (including a number-like type) to indicate that it should be lazily broadcast.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.DNE" href="#ChainRulesCore.DNE"><code>ChainRulesCore.DNE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DNE()</code></pre><p>This differential indicates that the derivative Does Not Exist (D.N.E). This is not the cast that it is not implemented, but rather that it mathematically is not defined.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.InplaceableThunk" href="#ChainRulesCore.InplaceableThunk"><code>ChainRulesCore.InplaceableThunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InplaceableThunk(val::Thunk, add!::Function)</code></pre><p>A wrapper for a <code>Thunk</code>, that allows it to define an inplace <code>add!</code> function, which is used internally in <code>accumulate!(Δ, ::InplaceableThunk)</code>.</p><p><code>add!</code> should be defined such that: <code>ithunk.add!(Δ) = Δ .+= ithunk.val</code> but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal <code>Thunk</code>).</p><p>Most operations on an <code>InplaceableThunk</code> treat it just like a normal <code>Thunk</code>; and destroy its inplacability.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.One" href="#ChainRulesCore.One"><code>ChainRulesCore.One</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia"> One()</code></pre><p>The Differential which is the multiplicative identity. Basically, this represents <code>1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Thunk(()-&gt;v)</code></pre><p>A thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a differential. <code>@thunk(v)</code> is a macro that expands into <code>Thunk(()-&gt;v)</code>.</p><p>Calling a thunk, calls the wrapped closure. <code>extern</code>ing thunks applies recursively, it also externs the differial that the closure returns. If you do not want that, then simply call the thunk</p><pre><code class="language-none">julia&gt; t = @thunk(@thunk(3))
Thunk(var&quot;##7#9&quot;())

julia&gt; extern(t)
3

julia&gt; t()
Thunk(var&quot;##8#10&quot;())

julia&gt; t()()
3</code></pre><p><strong>When to <code>@thunk</code>?</strong></p><p>When writing <code>rrule</code>s (and to a lesser exent <code>frule</code>s), it is important to <code>@thunk</code> appropriately. Propagation rule&#39;s that return multiple derivatives are not able to do all the computing themselves.  By <code>@thunk</code>ing the work required for each, they then compute only what is needed.</p><p><strong>So why not thunk everything?</strong></p><p><code>@thunk</code> creates a closure over the expression, which (effectively) creates a <code>struct</code> with a field for each variable used in the expression, and call overloaded.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. Examples being:</p><ul><li>The expression wrapping something in a <code>struct</code>, such as <code>Adjoint(x)</code> or <code>Diagonal(x)</code></li><li>The expression being a constant</li><li>The expression being itself a <code>thunk</code></li><li>The expression being from another <code>rrule</code> or <code>frule</code> (it would be <code>@thunk</code>ed if required by the defining rule already)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Wirtinger" href="#ChainRulesCore.Wirtinger"><code>ChainRulesCore.Wirtinger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Wirtinger(primal::Union{Number,AbstractDifferential},
          conjugate::Union{Number,AbstractDifferential})</code></pre><p>Returns a <code>Wirtinger</code> instance representing the complex differential:</p><pre><code class="language-none">df = ∂f/∂z * dz + ∂f/∂z̄ * dz̄</code></pre><p>where <code>primal</code> corresponds to <code>∂f/∂z * dz</code> and <code>conjugate</code> corresponds to <code>∂f/∂z̄ * dz̄</code>.</p><p>The two fields of the returned instance can be accessed generically via the <a href="@ref"><code>wirtinger_primal</code></a> and <a href="@ref"><code>wirtinger_conjugate</code></a> methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Zero" href="#ChainRulesCore.Zero"><code>ChainRulesCore.Zero</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Zero()</code></pre><p>The additive identity for differentials. This is basically the same as <code>0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.extern-Tuple{Any}" href="#ChainRulesCore.extern-Tuple{Any}"><code>ChainRulesCore.extern</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extern(x)</code></pre><p>Return <code>x</code> converted to an appropriate non-<code>AbstractDifferential</code> type, for use with external packages that might not handle <code>AbstractDifferential</code> types.</p><p>Note that this function may return an alias (not necessarily a copy) to data wrapped by <code>x</code>, such that mutating <code>extern(x)</code> might mutate <code>x</code> itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">frule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (ṡelf, ẋ₁, ẋ₂, ...) -&gt; Ω̇₁, Ω̇₂, ...)</code></pre><p>The second return value is the propagation rule, or the pushforward. It takes in differentials corresponding to the inputs (<code>ẋ₁, ẋ₂, ...</code>) and <code>ṡelf</code> the internal values of the function (for closures).</p><p>If no method matching <code>frule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sinx, sin_pushforward = frule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pushforward(NamedTuple(), 1) == cos(x)
true</code></pre><p>unary input, binary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sincosx, sincos_pushforward = frule(sincos, x);

julia&gt; sincosx == sincos(x)
true

julia&gt; sincos_pushforward(NamedTuple(), 1) == (cos(x), -sin(x))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.refine_differential-Tuple{Type{#s15} where #s15&lt;:(Union{AbstractArray{#s17,N} where N where #s17&lt;:Real, #s16} where #s16&lt;:Real),Wirtinger}" href="#ChainRulesCore.refine_differential-Tuple{Type{#s15} where #s15&lt;:(Union{AbstractArray{#s17,N} where N where #s17&lt;:Real, #s16} where #s16&lt;:Real),Wirtinger}"><code>ChainRulesCore.refine_differential</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">refine_differential(𝒟::Type, der)</code></pre><p>Converts, if required, a differential object <code>der</code> (e.g. a <code>Number</code>, <code>AbstractDifferential</code>, <code>Matrix</code>, etc.), to another  differential that is more suited for the domain given by the type 𝒟. Often this will behave as the identity function on <code>der</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rrule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̄₁, Ω̄₂, ...) -&gt; (s̄elf, x̄₁, x̄₂, ...))</code></pre><p>Where the second return value is the the propagation rule or pullback. It takes in differentials corresponding to the outputs (<code>x̄₁, x̄₂, ...</code>), and <code>s̄elf</code>, the internal values of the function itself (for closures)</p><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sinx, sin_pullback = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pullback(1) == (NO_FIELDS, cos(x))
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x, y = rand(2);

julia&gt; hypotxy, hypot_pullback = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; hypot_pullback(1) == (NO_FIELDS, (x / hypot(x, y)), (y / hypot(x, y)))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.store!-Tuple{Any,Any}" href="#ChainRulesCore.store!-Tuple{Any,Any}"><code>ChainRulesCore.store!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">store!(Δ, ∂)</code></pre><p>Stores <code>∂</code>, in <code>Δ</code>, overwriting what ever was in <code>Δ</code> before. potentially avoiding intermediate temporary allocations that might be necessary for alternative approaches  (e.g. <code>copyto!(Δ, extern(∂))</code>)</p><p>Like <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a> and <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>accumulate!</code></a>, this function is intended to be customizable for specific rules/input types.</p><p>See also: <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>accumulate!</code></a>, <a href="@ref"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-none">function ChainRulesCore.frule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (_, Δx₁, Δx₂, ...) -&gt; (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (ΔΩ₁, ΔΩ₂, ...) -&gt; (
            NO_FIELDS,
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>At present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always <code>NO_FIELDS</code>. And in forward-mode, the first input to the returned propagator is always ignored.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRulesCore&#39; <code>rules</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="@ref"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.AbstractDifferential" href="#ChainRulesCore.AbstractDifferential"><code>ChainRulesCore.AbstractDifferential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The subtypes of <code>AbstractDifferential</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>All subtypes of <code>AbstractDifferential</code> implement the following operations:</p><p><code>+(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></p><p><code>*(a, b)</code>: multiply the differential <code>a</code> by the differential <code>b</code></p><p><code>Base.conj(x)</code>: complex conjugate of the differential <code>x</code></p><p><code>extern(x)</code>: convert <code>x</code> into an appropriate non-<code>AbstractDifferential</code> type for use outside of <code>ChainContext</code>.</p><p>Valid arguments to these operations are <code>T</code> where <code>T&lt;:AbstractDifferential</code>, or where <code>T</code> has proper <code>+</code> and <code>*</code> implementations.</p><p>Additionally, all subtypes of <code>AbstractDifferential</code> support <code>Base.iterate</code> and <code>Base.Broadcast.broadcastable(x)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}" href="#ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}"><code>ChainRulesCore._normalize_scalarrules_macro_input</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_normalize_scalarrules_macro_input(call, maybe_setup, partials)</code></pre><p>returns (in order) the correctly escaped:     - <code>call</code> with out any type constraints     - <code>setup_stmts</code>: the content of <code>@setup</code> or <code>nothing</code> if that is not provided,     -  <code>inputs</code>: with all args having the constraints removed from call, or         defaulting to <code>Number</code>     - <code>partials</code>: which are all <code>Expr{:tuple,...}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.accumulate!-Tuple{Any,Any}" href="#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>ChainRulesCore.accumulate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accumulate!(Δ, ∂)</code></pre><p>Similar to <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a>, but attempts to compute <code>Δ + rule(args...)</code> in-place, storing the result in <code>Δ</code>.</p><p>Note: this function may not actually store the result in <code>Δ</code> if <code>Δ</code> is immutable, so it is best to always call this as <code>Δ = accumulate!(Δ, ∂)</code> just in-case.</p><p>This function is overloadable by using a <a href="@ref"><code>InplaceThunk</code></a>. See also: <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,Any}"><code>store!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.accumulate-Tuple{Any,Any}" href="#ChainRulesCore.accumulate-Tuple{Any,Any}"><code>ChainRulesCore.accumulate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accumulate(Δ, ∂)</code></pre><p>Return <code>Δ + ∂</code> evaluated in a manner that supports ChainRulesCore&#39;s various <code>AbstractDifferential</code> types.</p><p>See also: <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,Any}"><code>accumulate!</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,Any}"><code>store!</code></a>, <a href="@ref"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.propagation_expr-Tuple{Any,Any,Any}" href="#ChainRulesCore.propagation_expr-Tuple{Any,Any,Any}"><code>ChainRulesCore.propagation_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propagation_expr(𝒟, Δs, ∂s)

Returns the expression for the propagation of
the input gradient `Δs` though the partials `∂s`.

𝒟 is an expression that when evaluated returns the type-of the input domain.
For example if the derivative is being taken at the point `1` it returns `Int`.
if it is taken at `1+1im` it returns `Complex{Int}`.
At present it is ignored for non-Wirtinger derivatives.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.propagator_name-Tuple{Expr,Symbol}" href="#ChainRulesCore.propagator_name-Tuple{Expr,Symbol}"><code>ChainRulesCore.propagator_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propagator_name(f, propname)</code></pre><p>Determines a reasonable name for the propagator function. The name doesn&#39;t really matter too much as it is a local function to be returned by <code>frule</code> or <code>rrule</code>, but a good name make debugging easier. <code>f</code> should be some form of AST representation of the actual function, <code>propname</code> should be either <code>:pullback</code> or <code>:pushforward</code></p><p>This is able to deal with fairly complex expressions for <code>f</code>:</p><pre><code class="language-none">julia&gt; propagator_name(:bar, :pushforward)
:bar_pushforward

julia&gt; propagator_name(esc(:(Base.Random.foo)), :pullback)
:foo_pullback</code></pre></div></div></section><footer><hr/><a class="previous" href="getting_started.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a></footer></article></body></html>
